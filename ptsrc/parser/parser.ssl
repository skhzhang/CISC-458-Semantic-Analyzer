%  PT Parser.ssl	v1.01
%
% Date:  30 Jun 1980
%	 (revised 7 December 2009)
%
% Author:  Alan Rosselet
%
% Abstract
%
%     This module parses the syntax token stream emitted by the scanner
%   and emits a postfix stream of tokens to the semantic analyzer
%   module.  The parser detects and repairs syntax errors so that the
%   token stream emitted to the semantic analyzer is syntactically
%   legal (except for the special case of declaration phase errors - see
%   comment in the Block routine below).

Input :
	% Keywords must be first both here and in stdIdentifiers,
	% and they must appear in the same order

	pDiv			'div'
	firstKeywordToken = pDiv 
	pMod			'mod'
	pOr			'or'
	pAnd			'and'
	pNot			'not'
%	pThen			'then' removed old keyword
	pElse			'else'
	pOf			'of'
%	pEnd			'end' removed old keyword
%	pUntil			'until' removed old keyword
%	pDo			'do' removed old keyword
	pArray			'array'
	pFile			'file'
	pPacked			'packed'
	pProgram		'program'
%	pConst			'const' removed old keyword
	pVar			'var'
	pType			'type'
%	pProcedure		'procedure' removed old keyword
%	pBegin			'begin' removed old keyword
	pIf			'if'
	pCase			'case'
%	pWhile			'while' removed old keyword
% 	pRepeat			'repeat' removed old keyword

	% new tokens
	pLet			'let'
	pFunction		'function'
	pSwitch			'switch'
	pDefault		'default'
	pElseif			'elsif'
	pLoop			'loop'
	pBreak			'break'
	pWhen			'when'
	pClass			'class'
	pPublic			'public'
	lastKeywordToken = pPublic % changed lastKeywordToken from pRepeat to pPublic

	pIdentifier 
	firstCompoundInputToken = pIdentifier
	pInteger
	pLiteral
	lastCompoundInputToken = pLiteral

	pNewLine
	pEndFile
	pPlus			'+'
	pMinus			'-'
	pStar			'*'
	pColonEquals		':='
	pDot			'.'
	pComma			','
	pSemicolon		';'
	pColon			':'
	pEquals			'='
	pNotEqual		'!=' % changed <> to !=
	pLess			'<'
	pLessEqual		'<='
	pGreaterEqual		'>='
	pGreater		'>'
	pLeftParen		'('
	pRightParen		')'
	pLeftBracket		'['
	pRightBracket		']'
	pLeftBrace		'{' % add new token for left brace
	pRightBrace		'}' % add new token for right brace
	pDotDot			'..'	
	pSlash			'/' % add new token for slash
	pHash			'#' % add new token for hash
	pExclam			'!' % add new token for exclamation point
	pAt			'@' % add new token for at character
	pDoubleEq		'==' % add new token for double equals symbols
	lastSyntaxToken = pDoubleEq;

Output :
	sIdentifier 
	firstSemanticToken = sIdentifier
	firstCompoundSemanticToken = sIdentifier
	sInteger
	sLiteral
	lastCompoundSemanticToken = sLiteral

	sProgram
	sParmBegin
	sParmEnd
	sConst
	sType
	sVar
	sProcedure
	sBegin
	sEnd
	sNegate
	sArray
	sPacked
	sFile
	sRange
	sCaseStmt
	sCaseEnd
	sLabelEnd
	sExpnEnd
	sNullStmt
	sAssignmentStmt
	sSubscript
	sCallStmt
	sFieldWidth
	sIfStmt
	sThen
	sElsif % added new semantic token to represent the elsif statement
	sElse
%	sWhileStmt % remove old token
%	sRepeatStmt % remove old token
%	sRepeatEnd  % remove old token
	sEq
	sNE
	sLT
	sLE
	sGT
	sGE
	sAdd
	sSubtract
	sMultiply
	sDivide
	sModulus
	sInfixOr
	sOr
	sInfixAnd
	sAnd
	sNot
	sNewLine

% new semantic tokens
	sPublic
	sDefault
	sClass
	sLoopStmt
	sLoopBreakWhen
	sLoopEnd
	sSubstring
	sLength

	lastSemanticToken = sLength; % changed from sNewLine to sLength


rules

Program :
	'program'  .sProgram
	% program name
	pIdentifier
	% program parameters
	'('
	{
	    pIdentifier  .sIdentifier
	    [
		| ',':
		| *:
		    >
	    ]
	}
	')'
	.sParmEnd
	'{'  @Block  '}';

Block :
	@Declarations
	@Statement;

Declarations :
	% This is a new rule made for declarations.
	% It will replace part of the statements in Blocks
	{[
	    | 'let':
		.sConst
		@ConstantDefinitions
	    | 'type':
		.sType
		@TypeDefinitions
	    | 'var':
		.sVar
		@VariableDeclarations
	% Split procedure into 2 part, one for public procedure, one for general procedure.
	    | 'public':
		'function'
		.sProcedure
		.sPublic
		%procedure name
		pIdentifier  .sIdentifier
		@ProcedureHeading
		@Block
	    | 'function':
		.sProcedure
		% procedure name
		pIdentifier  .sIdentifier
		@ProcedureHeading
		@Block
	    | 'class':
		.sClass
		pIdentifier .sIdentifier
		@Block
	    | *:
		>
	]};

ConstantDefinitions :
	% Accept one or more named constant definitions
	pIdentifier  .sIdentifier
	@ConstantValue ';'
	{[
	    | pIdentifier:
		.sIdentifier
		@ConstantValue ';'
	    | *:
		>
	]};

ConstantValue :
	'='
	[
	    | pInteger:
		.sInteger
	    | pIdentifier:
		.sIdentifier
	    | '-':
		@UnsignedIntegerConstant
		.sNegate
	    | '+':
		@UnsignedIntegerConstant
	    | pLiteral:
		.sLiteral
	];

UnsignedIntegerConstant :
	[
	    | pIdentifier:
		.sIdentifier
	    | pInteger:
		.sInteger
	];

TypeDefinitions :
	% Accept one or more named type definitions.
	pIdentifier  .sIdentifier
	% Here changed = to :
	':' @TypeBody ';'
	{[
	    | pIdentifier:
		.sIdentifier
		% Here changed = to :
		':'  @TypeBody  ';'

	    | *:
		>
	]};
	

TypeBody :
	[
	    | 'packed':
		'array'  .sArray  .sPacked
		'['  @SimpleType  ']'
		'of'  @SimpleType
	    | 'array':
		.sArray
		'['  @SimpleType  ']'
		'of'  @SimpleType
	    | 'file':
		.sFile
		'of'  @SimpleType
	    | *:
		@SimpleType
	];

SimpleType :
	% A simple type is a named type (possibly predefined)
	% or a subrange type specification
	[
	    | pIdentifier:
		.sIdentifier
		[
		    | '..':
			.sRange		%% this may be unnecessary
			@OptionallySignedIntegerConstant
		    | *:
		]
	    | *:
		@OptionallySignedIntegerConstant
		'..'  .sRange
		@OptionallySignedIntegerConstant
	];

OptionallySignedIntegerConstant :
	[
	    | '-':
		@UnsignedIntegerConstant
		.sNegate
	    | '+':
		@UnsignedIntegerConstant
	    | *:
		@UnsignedIntegerConstant
	];

VariableDeclarations :
	% Accept one or more variable declarations.
	pIdentifier  .sIdentifier
	% ':'  @TypeBody  ';'
	{[
	% Line added here to allow a sequence of varialbe declarations
	    | ',':
		.sVar
	    	pIdentifier .sIdentifier
		% ':'  @TypeBody  ';'
	    | *:
		>
	]}
	':' @TypeBody ';' ;

ProcedureHeading :
	% Accept zero or more procedure formal parameter declarations.
	'('
	    {
		% formal parameter identifier
		[
		    | 'var':
			pIdentifier  .sIdentifier
			.sVar
		    | pIdentifier:
			.sIdentifier
		    | *:
			>		
		]
		':'
		% type identifier
		pIdentifier  .sIdentifier
		[
		    | ',':

		    | * :
			>
		]
	    }
	')'
	.sParmEnd;

Statement :
	{[
	    | pIdentifier:
		@AssignmentOrCallStmt
	    | 'if':
		@IfStmt
	    | 'while':
		@WhileStmt
	    | 'switch': % replaced by switch keyword for new JT syntax
		@CaseStmt
	    | 'repeat':
		@RepeatStmt
	    | 'loop':   % add new loop keyword for JT
		@LoopStmt
	    | '{': 
		@NestedBlock
		
	    | *:
		.sNullStmt
		>
	]};

AssignmentOrCallStmt :
	[
	    | '=': % assignment operator changed from := to a single equals symbol
		.sAssignmentStmt
		.sIdentifier	% identifier accepted in the Statement rule
		@Expression
		';'
		.sExpnEnd
	    | '[':
		.sAssignmentStmt
		.sIdentifier
		.sSubscript
		@Expression
		.sExpnEnd
		']'  '=' % assignment operator changed from := to a single equals symbol
		@Expression
		.sExpnEnd
	    | *:
		@CallStmt
	];

CallStmt :
	.sIdentifier	% procedure identifier accepted in the Statement rule
	% accept zero or more actual parameters
	[
	    % | '(':
		{
		    @Expression
		    .sExpnEnd
		    % allow a field width specification to occur in calls
		    % to the standard procedures write and writeln
		    [
			| ':':
			    .sFieldWidth
			    @Expression
			    .sExpnEnd
			| *:
		    ]
		    [
			| ',':
			| *:
			    >
		    ]
		}
		% ')'
	    | *:	% no actual parameters
	]
	.sParmEnd;

BeginStmt :
	.sBegin
	    @Statement
	    [
		| ';':
		| '}': % replaced end keyword with new JT style block ending with } right curly brace; this will indicate the end of a statement and emit the corresponding output token
		    .sEnd
		    >
	    ];

NestedBlock :
	.sBegin
	@Statement
	{[
			|';':
			| *: 
				@Statement	
			| '}':
				.sEnd
				>
	]};


IfStmt :
	.sIfStmt
	@Expression
	.sExpnEnd
	% removed the necessity of a 'then' keyword, as the sThen semantic token should be emitted after every if and elsif statement
	.sThen
	@Statement
	{[
	   | 'elsif': 
		@ElsifStmt
	   | *:
		>
	]}
	[
	    | 'else':
		.sElse
		@Statement
	    | *:
		>
	];


ElsifStmt:
	.sElsif
	@Expression
	.sExpnEnd
	.sThen
	@Statement;


CaseStmt :
	.sCaseStmt
	@Expression
	.sExpnEnd
	'{'
	% 'of' removed of keyword for new switch statement in JT
	'case'
	@CaseAlternative
	{[
	    %| ';':
		% since case alternatives cannot be null, allow
		% for the common situation of an extra semicolon
		% at the end of the list of case alternatives.
	    | '}': % replaced end keyword with new JT style block ending with } right curly brace; this will indicate the list of case alternatives
		>
	    | 'case':
		@CaseAlternative
	    | 'default': 
		@DefaultStmt
	]}
	.sCaseEnd;


CaseAlternative :
	% A case alternative is a statement labelled by
	% one or more optionally signed integer constants
	   
		% | ',':
	@OptionallySignedIntegerConstant
	':'
	[
		| 'break':
			';'    
			>
		| *: 
			.sBegin
			{[
				@Statement
			]}			
			.sEnd
	]
	.sLabelEnd;
	%':'  @Statement;


% added new rule for default statements in switch statements, will take one statement and end the case afterwards
DefaultStmt:
	':' : @BeginStmt
	'break'
	';'
	.sCaseEnd;


WhileStmt :
	.sWhileStmt
	@Expression
	.sExpnEnd
	'do'
	@Statement;

RepeatStmt :
	.sRepeatStmt
	{
	    @Statement
	    [
		| ';':
		| 'until':
		    .sRepeatEnd
		    >
	    ]
	}
	@Expression
	.sExpnEnd;

LoopStmt : % add new loop statement functionality to JT
	.sLoopStmt
	@Statement
	pBreak:
	pWhen
	.sLoopBreakWhen
	@Expression
	.sExpnEnd
	@Statement
	.sLoopEnd;

Expression :
	@SimpleExpression
	[
	    % added guard for double equals symbol, will emit sEq token like a single equal symbol
	    | '==':
		@SimpleExpression .sEq
	    | '=':
		@SimpleExpression  .sEq
	    | '!=': % changed <> to !=
		@SimpleExpression  .sNE
	    | '<':
		@SimpleExpression  .sLT
	    | '<=':
		@SimpleExpression  .sLE
	    | '>':
		@SimpleExpression  .sGT
	    | '>=':
		@SimpleExpression  .sGE
	    | *:
	];

SimpleExpression :
	[
	    | '+':
		@Term
	    | '-':
		@Term  .sNegate
	    | *:
		@Term
	]
	{[
	    | '+':
		@Term  .sAdd
	    | '-':
		@Term  .sSubtract
	    | 'or':
		.sInfixOr  @Term  .sOr
	    | *:
		>
	]};

Term :
	@Substring
	{[
	    | '*':
		@Factor  .sMultiply
	    | 'div':
		@Factor  .sDivide
	    | 'mod':
		@Factor  .sModulus
	    | 'and':
		.sInfixAnd  @Factor  .sAnd
	    | *:
		>
	]};

Substring: % new rule for new precedence level for handling substrings
	@Factor
	[
	    | pAt: % add substring for JT
		pInteger
		.sInteger
		pColon
		pInteger
		.sInteger
		.sSubstring
	    | *:
		
	];

Factor :
	[
	    | pIdentifier:
		.sIdentifier
		@IdentifierExtension
	    | pInteger:
		.sInteger
	    | '(':
		@Expression  ')'
	    | pHash:		% add string length operator for JT
		@Expression		
		.sLength
	    | 'not':
		@Factor
		.sNot
	    | pLiteral:
		.sLiteral
	    | 'file':
		.sFile '(' @Expression ')'
		.sExpnEnd
	];

IdentifierExtension :
	% Handle subscripts and function actual parameter lists
	[
	    | '[':
		.sSubscript
		@Expression  ']'
		.sExpnEnd
	    | '(':
		.sParmBegin
		@Expression  ')'
		.sExpnEnd
		.sParmEnd
	    | *:
	];
end
